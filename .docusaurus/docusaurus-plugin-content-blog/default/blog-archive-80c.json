{
  "blogPosts": [
    {
      "id": "id-generator",
      "metadata": {
        "permalink": "/blog/id-generator",
        "editUrl": "https://github.com/chientranthien/docs/tree/master/blog/id_generator/id_generator.mdx",
        "source": "@site/blog/id_generator/id_generator.mdx",
        "title": "Distributed Id Generator",
        "description": "Background",
        "date": "2023-12-13T00:00:00.000Z",
        "formattedDate": "December 13, 2023",
        "tags": [
          {
            "label": "idgenerator",
            "permalink": "/blog/tags/idgenerator"
          },
          {
            "label": "sharding",
            "permalink": "/blog/tags/sharding"
          }
        ],
        "readingTime": 3.31,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Chien Tran",
            "title": "Maintainer",
            "url": "https://github.com/chientranthien",
            "imageURL": "https://github.com/chientranthien.png",
            "key": "chien"
          }
        ],
        "frontMatter": {
          "slug": "id-generator",
          "title": "Distributed Id Generator",
          "authors": "chien",
          "date": "2023-12-13T00:00:00.000Z",
          "tags": [
            "idgenerator",
            "sharding"
          ]
        }
      },
      "content": "## Background\n\nIn modern distributed systems, where applications and data are spread across\nmultiple servers, generating unique and globally consistent identifiers becomes\ncrucial. This is where a distributed ID generator comes in.\n\nHere are some key reasons why a distributed ID generator is needed:\n\n**1. Scalability:** Traditional ID generation methods, like auto-incrementing\ndatabases, struggle to scale horizontally. A distributed ID generator allows any\nserver to independently generate IDs, eliminating the need for a central\nbottleneck. This enables a system to handle high volumes of requests and easily\nadd more servers as needed.\n\n**2. High Availability:** Distributed ID generators typically don't have a\nsingle point of failure. If one server goes down, others can continue generating\nIDs without interruption. This ensures system uptime and data integrity,\nespecially in a critical environment.\n\n**3. Efficiency:** Distributed ID generators can be designed to generate IDs\nefficiently, minimizing CPU and network overhead. This helps maintain system\nperformance even under high loads.\n\n**4. Security:** Some distributed ID generators offer features like random ID\ngeneration or cryptographic hashing to enhance security and prevent potential ID\ncollisions or manipulation.\n\nHere are some specific examples of how distributed ID generators are used:\n\n- **Microservices**: Each microservice can generate its own IDs without relying\n  on a central service, leading to a more loosely coupled and scalable\n  architecture.\n- **Event-driven systems**: Unique IDs are crucial for tracking events across\n  different components of a distributed system.\n- **Messaging systems**: Each message needs a unique ID for identification and\n  routing.\n- **Data pipelines**: Data items require unique IDs for proper tracking and\n  processing across different stages of a pipeline.\n\nIn this Blog, I will present one of the way to implement a\ndistributed `ID Generator` based\non [Snowflake](https://en.wikipedia.org/wiki/Snowflake_ID)\n\n## Design\n\n### Architecture\n\n![architecture](./flow.png)\nIn order to generate a new id, the `Business` application will need to call one\nof the `ID Generator` instances. The `ID Generator` then will generate the id\nand return in the response.\n\n### ID Format\n\n![id](./id.png)\n\nWe can split the ID into 3 parts\n\n- **Timestamp**: to optimize the space you may consider to not use UNIX epoch\n  which is the number of seconds that have elapsed since 1970. And choose your\n  own start date. i.e your development start from 2023, you can consider to 2023\n  as the start date\n- **Machine ID**: is the id of the `ID Generator`  instance which is assigned at\n  the startup time. you should choose the number of slots for the `Machine ID`\n  that shouldn't be too big because it will occupy the space of other parts. And\n  shouldn't be too small because it will affect the number of instances of the\n  id generator which in turn affect the scalability\n- **Sequence Number**: used to avoid the collision of a new generated id at the\n  same timestamp of the same `ID Generator` instance. you should give it enough\n  space so the number of uniq sequence number of it generator instance can\n  handle your max QPS\n\n### Startup\n\n![starup](./startup.png)\nDuring the startup of a `ID Generator` instance, it should obtain\nthe `Machine ID` before start to serve the traffics of the clients to generate\nids. One of the way to do this is to have a list of pre-defined `Machine ID` in\nthe DB. And the instance will try to get one available `Machine ID` with lock to\navoid race condition. Then obtain the `Machine ID` by updating the record in the\nDB with the new owner is the current `ID Generator` instance, and new lease time\nto avoid a dead instance to hold the `Machine ID` forever\n\n### Heart Beat / Extend The Lease\n\n![lease](./lease.png)\nIn order to avoid a dead instance hold the `Machine ID` forever, each instance\nshould set a lease time and extend it periodically. If it fail to extend the\nlease, it should stop receiving the request to generate id because\nthe `Machine ID` may be obtained by another instance and can cause collision if\nthe instance keep serving the requests"
    }
  ]
}